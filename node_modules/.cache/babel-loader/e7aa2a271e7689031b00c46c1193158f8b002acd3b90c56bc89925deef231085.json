{"ast":null,"code":"import _classCallCheck from\"/home/mohanned/Downloads/battleship/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"/home/mohanned/Downloads/battleship/node_modules/@babel/runtime/helpers/esm/createClass.js\";var Gameboard=/*#__PURE__*/function(){function Gameboard(board){_classCallCheck(this,Gameboard);this.board=board||[];// allow user to pass in their own board to borrow methods for testing\nif(!this.board.length)this.init();}_createClass(Gameboard,[{key:\"init\",value:function init(){for(var i=0;i<100;i++){this.board.push({hasShip:false,isShot:false});}}},{key:\"receiveShot\",value:function receiveShot(location){this.board[location].isShot=true;}},{key:\"checkIfShotHit\",value:function checkIfShotHit(location){// return true for hit, false for miss\nreturn this.board[location].hasShip;}},{key:\"createLocationArray\",value:function createLocationArray(location,ship,axis){var locationArray=[];for(var i=0;i<ship.length;i++){axis==='x'?locationArray.push(location+i):locationArray.push(location+i*10);}return locationArray;}},{key:\"checkCollisions\",value:function checkCollisions(locationArray){var _this=this;// on x axis, if a ship shares this cell with the next, there is a wall collision\nvar collisions=[9,19,29,39,49,59,69,79,89];if(locationArray.some(function(loc){return!_this.board[loc];})){// check if ship placement exceeds board boundaries, which covers y axis\nreturn false;}else if(locationArray.some(function(loc){return _this.board[loc].hasShip;})){// check for collisions with other ships\nreturn false;}else if(collisions.some(function(num){// see comment on collisions array\nreturn[num,num+1].every(function(combination){return locationArray.includes(combination);});})){return false;}else{return true;}}},{key:\"findRandomShipLocation\",value:function findRandomShipLocation(ship){var _this2=this;// get a random axis\nvar randomAxis=function randomAxis(){return['x','y'][Math.floor(Math.random()*2)];};// return a location array that will fit this ship\nvar findSuitableLocation=function findSuitableLocation(axis){var possibleLocationArrays=[];for(var i=0;i<100-ship.length;i++){// make every possible location the ship can exist as an array\nvar locationArray=[];if(axis==='x'){for(var count=0;count<ship.length;count++){locationArray.push(i+count);}}else{for(var _count=0;_count<ship.length;_count++){locationArray.push(i+_count*10);}}// test if this location will work, if so, push to the collection of possibilities\nif(_this2.checkCollisions(locationArray)){possibleLocationArrays.push(locationArray);}}// return a random choice\nreturn possibleLocationArrays[Math.floor(Math.random()*possibleLocationArrays.length)];};return findSuitableLocation(randomAxis());}// this returns a version of the game board that represents what the opponent is allowed to see\n},{key:\"opponentBoard\",value:function opponentBoard(){return this.board.map(function(cell){return cell.isShot&&cell.hasShip?'hit':cell.isShot?'miss':'empty';});}}]);return Gameboard;}();export default Gameboard;","map":{"version":3,"names":["Gameboard","board","length","init","i","push","hasShip","isShot","location","ship","axis","locationArray","collisions","some","loc","num","every","combination","includes","randomAxis","Math","floor","random","findSuitableLocation","possibleLocationArrays","count","checkCollisions","map","cell"],"sources":["/home/mohanned/Downloads/battleship/src/factories/gameboardFactory.js"],"sourcesContent":["class Gameboard {\n\tconstructor(board) {\n\t\tthis.board = board || [];\n\t\t// allow user to pass in their own board to borrow methods for testing\n\t\tif (!this.board.length) this.init();\n\t}\n\n\tinit() {\n\t\tfor (let i = 0; i < 100; i++) {\n\t\t\tthis.board.push({ hasShip: false, isShot: false });\n\t\t}\n\t}\n\n\treceiveShot(location) {\n\t\tthis.board[location].isShot = true;\n\t}\n\n\tcheckIfShotHit(location) {\n\t\t// return true for hit, false for miss\n\t\treturn this.board[location].hasShip;\n\t}\n\n\tcreateLocationArray(location, ship, axis) {\n\t\tconst locationArray = [];\n\t\tfor (let i = 0; i < ship.length; i++) {\n\t\t\taxis === 'x'\n\t\t\t\t? locationArray.push(location + i)\n\t\t\t\t: locationArray.push(location + i * 10);\n\t\t}\n\t\treturn locationArray;\n\t}\n\n\tcheckCollisions(locationArray) {\n\t\t// on x axis, if a ship shares this cell with the next, there is a wall collision\n\t\tconst collisions = [9, 19, 29, 39, 49, 59, 69, 79, 89];\n\t\tif (locationArray.some((loc) => !this.board[loc])) {\n\t\t\t// check if ship placement exceeds board boundaries, which covers y axis\n\t\t\treturn false;\n\t\t} else if (locationArray.some((loc) => this.board[loc].hasShip)) {\n\t\t\t// check for collisions with other ships\n\t\t\treturn false;\n\t\t} else if (\n\t\t\tcollisions.some((num) => {\n\t\t\t\t// see comment on collisions array\n\t\t\t\treturn [num, num + 1].every((combination) =>\n\t\t\t\t\tlocationArray.includes(combination)\n\t\t\t\t);\n\t\t\t})\n\t\t) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfindRandomShipLocation(ship) {\n\t\t// get a random axis\n\t\tconst randomAxis = () => ['x', 'y'][Math.floor(Math.random() * 2)];\n\t\t// return a location array that will fit this ship\n\t\tconst findSuitableLocation = (axis) => {\n\t\t\tconst possibleLocationArrays = [];\n\t\t\tfor (let i = 0; i < 100 - ship.length; i++) {\n\t\t\t\t// make every possible location the ship can exist as an array\n\t\t\t\tlet locationArray = [];\n\t\t\t\tif (axis === 'x') {\n\t\t\t\t\tfor (let count = 0; count < ship.length; count++) {\n\t\t\t\t\t\tlocationArray.push(i + count);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (let count = 0; count < ship.length; count++) {\n\t\t\t\t\t\tlocationArray.push(i + count * 10);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// test if this location will work, if so, push to the collection of possibilities\n\t\t\t\tif (this.checkCollisions(locationArray)) {\n\t\t\t\t\tpossibleLocationArrays.push(locationArray);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return a random choice\n\t\t\treturn possibleLocationArrays[\n\t\t\t\tMath.floor(Math.random() * possibleLocationArrays.length)\n\t\t\t];\n\t\t};\n\t\treturn findSuitableLocation(randomAxis());\n\t}\n\t\n\t// this returns a version of the game board that represents what the opponent is allowed to see\n\topponentBoard() {\n\t\treturn this.board.map((cell) => {\n\t\t\treturn cell.isShot && cell.hasShip\n\t\t\t\t? 'hit'\n\t\t\t\t: cell.isShot\n\t\t\t\t? 'miss'\n\t\t\t\t: 'empty';\n\t\t});\n\t}\n}\n\nexport default Gameboard;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}